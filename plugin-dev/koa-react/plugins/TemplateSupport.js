"use strict";

const NodeMDA = require("nodemda");
const pluralize = require('pluralize');
const _ = require('lodash');
const OmniSchema = require('omni-schema');


/*
 * TemplateSupport.js
 * Contains code that applies to ALL class types generated by this
 * koa-react plugin.
 */
var TemplateSupport = {};

(function() {


    /**
     * In Javascript, associations to other objects are handled as
     * nested object properties.  A "many" association is simply an array
     * of those objects. This function transforms any associations on
     * a class object to be "just another attribute" on the class. 
     * The original attribute list and association list are saved in 
     * jsOriginalAttributes and jsOriginalAssociations in case they 
     * need to be examined.
     */
    function transformAssocsToAttribs(metaClass) {

	    /**
	     * Transforms all of the associations specified in metaClass
	     * into "Attribute" objects, returning them as an array of
	     * NodeMDA.Meta.Attribute objects.
	     */
	    function assocsToArrayAttribs(metaClass) {
	    	let attribs = [];
	    	metaClass.associations.forEach(function(metaAssoc) {
	    	   let myEnd = metaAssoc.myEnd;
	    	   let otherEnd = metaAssoc.otherEnd; 
	    	   if (otherEnd.isNavigable) {
	    		   let attrib = new NodeMDA.Meta.Attribute(otherEnd.name, otherEnd.type);
	    		   attrib._multiplicity = otherEnd._multiplicity;
	    		   attrib._public = otherEnd._public;
	    		   attrib._comment = otherEnd._comment;

	    		   if (otherEnd.type instanceof NodeMDA.Meta.ObjectDatatype) {
	    		   		let otherClass = otherEnd.type.metaClass;
	    		   		if (otherClass.stereotypeName === 'ValueObject' || otherClass.stereotypeName === 'POJO') {
	    		   			attrib.setSchemaDbProperty('persistence', 'embed');
	    		   		}

	    		   		if (otherClass.stereotypeName === 'Entity') {
	    		   			if (myEnd.isNavigable && myEnd.isOne && otherEnd.isMany) {
	    		   				// This is a one to many relationship - configure
	    		   				// as a foreign key...
	    		   				attrib.setSchemaDbProperty('foreignKeyField', myEnd.name);
	    		   			}
	    		   		}
	    		   }

	    		   attribs.push(attrib);
	    	   }	
	    	});
	    	return attribs;
	    };

       let jsAttributeList = metaClass.attributes.concat(assocsToArrayAttribs(metaClass));
       metaClass.jsOriginalAttributes = metaClass.attributes;
       metaClass.attributes = jsAttributeList;
       metaClass.jsOriginalAssociations = metaClass.associations;
       metaClass.associations = [];
    };
    
    

	/**
	 * Creates a minimal OmniSchema for the specified class and saves it in the
	 * "schema" property of the meta class object. This schema is used to create
	 * mock records by the unit test generation code.
	 */
	function makeSchema(metaClass) {

		// Build an OmniSchema for this class so we can mock a record...
		let schemaTemplate = {};
		metaClass.allVisibleAttributes.forEach(function(attrib) {
			if (attrib.isObject) {
				schemaTemplate[attrib.name] = { schema: attrib.type.metaClass.schemaCollectionName };
			}
			else {
				schemaTemplate[attrib.name] = { type: attrib.omniSchemaTypeName };
			}
			let omniField = schemaTemplate[attrib.name];
			omniField.validation = {};
			if (attrib.hasMinValue) {
				omniField.validation.min = attrib.minValue;
			}
			if (attrib.hasMaxValue) {
				omniField.validation.max = attrib.maxValue;
			}
		});

		metaClass.schema = OmniSchema.compile(schemaTemplate, metaClass.schemaCollectionName);
	}




    /**
     * Takes a string and translates it into a valid Javascript identifier.
     */
    TemplateSupport.jsPathToIdentifier = function(packagePath) {
    	if (typeof packagePath === "string") {
    		return packagePath.replace(new RegExp("\\" + NodeMDA.Options.packageDelimeter, "g"), ".");
    	}
    	else {
    		return "";
    	}
    };
    

	TemplateSupport.initPlatform = function(context) {

		let model = context.model;

		Object.defineProperty(model, 'entities', {
			get: function() { 
				let entityList = [];
				this.classes.forEach(function(metaClass) {
					if (metaClass.stereotypeName === 'Entity') {
						entityList.push(metaClass);
					}
				});
				return entityList;
			}
		});

		model.mixin({

			onAttribute: [ 
			   { get: [
					/**
					 * jsIdentifierName is the name to use as the identifier name
					 * for an attribute in a class when generating Javascript code. 
					 * The convention used is that read only and private variables are prefixed
					 * with the "_" character.
					 */
					function jsIdentifierName() {
						if (this.isReadOnly || !this.isPublic) {
							// A private variable...
							return "_" + this.name;
						}
						else {
							return this.name;
						}

   					},


   					function schemaDbProperties() {

   						if (this.isObject) {
   							let metaClass = this.type.metaClass;
		    		   		if (metaClass.stereotypeName === 'ValueObject' || metaClass.stereotypeName === 'POJO') {
		    		   			this.setSchemaDbProperty('persistence', 'embed');
		    		   		}
	    		   		}


	    		   		if (this.isUnique) {
	    		   			this.setSchemaDbProperty('unique', true);
	    		   		}


   						if (this._schemaDbProp) {
   							return JSON.stringify(this._schemaDbProp);
   						}
   					},

   					/**
   					* Returns TRUE if this attribute is an object attribute that can and should be 
   					* imported and referenced directly by the schema.
   					*/
   					function importedBySchema() {

						if (this.isObject) {
							if (_.get(this, '_schemaDbProp.persistence') === 'embed' || 
								_.get(this, '_schemaDbProp.foreignKeyField')) {
									return true;
						    }
						}

						return false;
   					}


				]},
			     
			    { func: [
			    	function setSchemaDbProperty(name, value) {
			    		if (!this.hasOwnProperty('_schemaDbProp')) {
			    			this._schemaDbProp = {};
			    		}

			    		this._schemaDbProp[name] = value;
			    	},
			    ]},
			],


			onObjectDatatype: {
				get: [
				    /**
				     * Translates the metamodel's path delimeter into a Javascript appropriate
				     * identifier.
				     */
				    function jsClassNameWithPath() {
	    	   			return TemplateSupport.jsPathToIdentifier(this.classNameWithPath);
				   	}
				],
			},


			onClass: {
				get: [
				    /**
				     * Translates the metamodel's path delimeter into a Javascript appropriate
				     * identifier.
				     */
					function jsClassNameWithPath() {
	    	   			return TemplateSupport.jsPathToIdentifier(this.classNameWithPath);
					},
					

				    /**
				     * Translates the metamodel's package name to a valid Javascript identifier.
				     */
					function jsPackageName() {
	    	   			return TemplateSupport.jsPathToIdentifier(this.packageName);
					},

					function pluralName() {
						return pluralize(this.name);
					},


					function defaultExternalAccess() {
   						// By default, entities's Dao's are internal,
   						// unless there are security roles defined (in which
   						// case they are external but limited to the roles).
   						// All other items are by default, external unless
   						// explicitly turned off.
						if (this.stereotypeName === 'Entity') {
							return this.isRoleRestricted;
						}
						else {
							return true;
						}
					},


   					function allowExternalAccess() {
   						if (!this.hasTag('externalAccess')) {
   							return this.defaultExternalAccess;
   						}
   						else {
							return this.isTaggedAs('externalAccess');
   						}
   					},


					/**
					 * Returns a relative path to prefix import statements that allows
					 * any entry that is using the package path as part of its complete
					 * path to get back up to the parent.  For example, a class with
					 * no package can get to its parent with "..".  A class that is two
					 * levels deep can get to the parent with "../../.."
					 */
                    function relativeParentPrefix() {
						if (this.isRootPackage || this.packageDirName.length == 0) {
							return "..";
						}
						else {
						   const slashCount = (this.packageDirName.match(/\//g) || []).length;
						   return '..' +'/..'.repeat(slashCount+1); // Generate the relative prefix
						}
					},


					/**
					 * A path that includes the package name (if there is one).
					 * The string is formatted so {{packagedirPath}}{{class.name}}.js
					 * will resolve to something correctly without double slashes.
					 */
					function packageDirPath() {
						if (this.inRootPackage) {
							return "";
						}
						else {
							return `${this.packageDirName}/`;
						}
					},


					/**
					* Returns TRUE if there are any dependencies on this class to one or more
					* actors.
					*/
					function isRoleRestricted() {
						return this.roleList.length > 0;
					},


					/**
					 * Returns an array of roles this class is dependent on.  Note
					 * that role dependencies are inherited from parent classes
					 */
					function roleList() {
						if (this.hasOwnProperty('__roleList')) {
							return this.__roleList;
						}

						let roles = [];
						if (this.isSubClass) {
							roles = this.parentClass.roleList;
						}

						this.dependentActors.forEach(function (actor) {
							let roleName = actor.name;
							if (roleName.endsWith('Role')) {
								roleName = _.camelCase(roleName.slice(0, -4));
							}
							roles.push(roleName);
						});

						this.__roleList = roles;

						return roles;
					},


					/**
					* Returns a list of all referenced objects that referenced for
					* direct import by a schema definition.
					*/ 
					function referencedForSchemaImport() {

						let refEmbed = [];

						this.attributes.forEach(function (attribute) {
							if (attribute.importedBySchema) {
								refEmbed.push(attribute.type.metaClass);
							}
						});

						return refEmbed;
					},


					/**
					* Returns the stringified version of the roles use.  It will be in the
					* format [ 'role1', 'role2',...]
					*/
					function stringifyRoleList() {
						let strList = JSON.stringify(this.roleList);
						return strList.replace(/"/g, '\'');
					},

					/**
					* Returns the string that should be used to identify this collection.
					*/
					function schemaCollectionName() {
   						return this.getClassNameWithPath('_');
					},

					function autogenPrimaryKey() {
						return this.stereotypeName === 'Entity' && !this.isSubClass;
					},

					function isUserEntity() {
						return this.stereotypeName === 'Entity' && this.name === 'User';
					}

				],

			},

			onMetaElement: {
				get: [
				    /**
				     * Returns an array of strings representing the comment of the object,
				     * broken down into individual lines that are no longer than (approx) maxCharsPerLine
				     * long.
				     */
	    			function jsCommentsFormatted() {
				    	var maxCharsPerLine = 80;
				    	var lineList = [];
				    	
				    	if (this.hasComment) {
				    		var words = this.comment.split(" ");
				    		var line = "";
				    		var lineLen = 0;
				    		for (var w = 0; w < words.length; w++) {
				    			var nextWord = words[w];
				    			var nextWordLen = nextWord.length;

				    			if (lineLen + nextWordLen > maxCharsPerLine) {
				    				line = line.replace(new RegExp("\\n", "g"), "<p>");
				    				lineList.push(line);
				    				line = "";
				    				lineLen = 0;
				    			}
				    			
				    			if (lineLen > 0) {
				    				line += " ";
				    				lineLen++;
				    			}
				    			
				    			line += nextWord;
				    			lineLen += nextWordLen;
				    		} // for
				    		
				    		if (lineLen > 0) {
			    				line = line.replace(new RegExp("\\n", "g"), "<p>");
				    			lineList.push(line);
				    		}
				    	}
				    	
				    	return lineList;
					},
				],
			},
		}); // end mixin


		// Transform the associations on all of the classes to simple object properties...
		model.classes.forEach(function (metaClass) {
			transformAssocsToAttribs(metaClass);
			let sname = metaClass.stereotypeName;
			if (sname === 'ValueObject' || sname === 'POJO' || sname === 'Entity') {
				makeSchema(metaClass);
			}
		});
	};

	
})();

module.exports = TemplateSupport;
