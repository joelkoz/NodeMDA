"use strict";

const NodeMDA = require("nodemda");
const pluralize = require('pluralize');
const _ = require('lodash');


/*
 * TemplateSupport.js
 * Contains code that applies to ALL class types generated by this
 * koa-react plugin.
 */
var TemplateSupport = {};

(function() {


    /**
     * In Javascript, associations to other objects are handled as
     * nested object properties.  A "many" association is simply an array
     * of those objects. This function transforms any associations on
     * a class object to be "just another attribute" on the class. 
     * The original attribute list and association list are saved in 
     * jsOriginalAttributes and jsOriginalAssociations in case they 
     * need to be examined.
     */
    function transformAssocsToAttribs(metaClass) {

	    /**
	     * Transforms all of the associations specified in metaClass
	     * into "Attribute" objects, returning them as an array of
	     * NodeMDA.Meta.Attribute objects.
	     */
	    function assocsToArrayAttribs(metaClass) {
	    	let attribs = [];
			let virtuals = [];
	    	metaClass.associations.forEach(function(metaAssoc) {
	    	   let myEnd = metaAssoc.myEnd;
	    	   let otherEnd = metaAssoc.otherEnd; 
	    	   if (otherEnd.isNavigable) {
	    		   let attrib = new NodeMDA.Meta.Attribute(otherEnd.name, otherEnd.type);
	    		   attrib._multiplicity = otherEnd._multiplicity;
	    		   attrib._public = otherEnd._public;
	    		   attrib._comment = otherEnd._comment;

	    		   if (otherEnd.type instanceof NodeMDA.Meta.ObjectDatatype) {
	    		   		let otherClass = otherEnd.type.metaClass;
	    		   		if (otherClass.stereotypeName === 'ValueObject' || otherClass.stereotypeName === 'POJO') {
	    		   			attrib.setSchemaDbProperty('persistence', 'embed');
	    		   		}

	    		   		if (otherClass.stereotypeName === 'Entity') {
	    		   			if (myEnd.isNavigable && myEnd.isOne && otherEnd.isMany) {
	    		   				// This is a one to many relationship - configure
	    		   				// as a foreign key...
	    		   				attrib.setSchemaDbProperty('foreignKeyField', myEnd.name);
	    		   			}
	    		   		}
	    		   }

				   if (myEnd.type.metaClass.isEntity && otherEnd.type.metaClass.isEntity) {
					    // Two associated Entity properties have special handling depending on the multiplicity
						if (otherEnd.isOne) {
								// For One to Many relationships, the "one" side holds
								// an actual reference to the other object Id as a real
								// property. The "many" side can use a virtual property and simply query
								// the database to gather the many members. Here, the "other" end
								// is a "one", so we make an actual attribute to hold the reference.
								attribs.push(attrib);
						}
						else if (myEnd.isMany && otherEnd.isMany) {
								// Many to Many relationship are modeled by an array that holds
								// a reference to the object Ids of the other objects. As with the
								// "one" side, we make an actual attribute to hold the references.
								// It will be generated as an array attribute since it is "many".
								attribs.push(attrib);
						}
						else {
								// If we are here, the other end is a many, but myEnd is a "one".
								// You can gather the other objects by querying the database using the
								// "one" side. Thus, we make this attribute a virtual property on
								// the entity.
								virtuals.push(attrib);
						}
					}
					else {
						// If any side is NOT an entity, just handle it as any other attribute.
						attribs.push(attrib);
					}
	    	   }
	    	});
	    	return { attribs, virtuals };
	    };

	   const {attribs, virtuals} = assocsToArrayAttribs(metaClass);
       let jsAttributeList = metaClass.attributes.concat(attribs);
       metaClass.jsOriginalAttributes = metaClass.attributes;
       metaClass.attributes = jsAttributeList;
       metaClass.jsOriginalAssociations = metaClass.associations;
       metaClass.associations = [];
	   metaClass.virtuals = virtuals;
    };
    



    /**
     * Takes a string and translates it into a valid Javascript identifier.
     */
    TemplateSupport.jsPathToIdentifier = function(packagePath) {
    	if (typeof packagePath === "string") {
    		return packagePath.replace(new RegExp("\\" + NodeMDA.Options.packageDelimeter, "g"), ".");
    	}
    	else {
    		return "";
    	}
    };
    

	TemplateSupport.initPlatform = function(context) {

		let model = context.model;

		Object.defineProperty(model, 'entities', {
			get: function() { 
				let entityList = [];
				this.classes.forEach(function(metaClass) {
					if (metaClass.stereotypeName === 'Entity') {
						entityList.push(metaClass);
					}
				});
				return entityList;
			}
		});

		model.mixin({

			onAttribute: [ 
			   { get: [
					/**
					 * jsIdentifierName is the name to use as the identifier name
					 * for an attribute in a class when generating Javascript code. 
					 * The convention used is that read only and private variables are prefixed
					 * with the "_" character.
					 */
					function jsIdentifierName() {
						// if (this.isReadOnly || !this.isPublic) {
						// 	return "_" + this.name;
						// }
						// else {
						// 	return this.name;
						// }
						return this.name;
   					},

 				    function singularName() {
						return pluralize(this.name, 1);
					},

   					function schemaDbProperties() {

   						if (this.isObject) {
   							let metaClass = this.type.metaClass;
		    		   		if (metaClass.stereotypeName === 'ValueObject' || metaClass.stereotypeName === 'POJO') {
		    		   			this.setSchemaDbProperty('persistence', 'embed');
		    		   		}
	    		   		}


	    		   		if (this.isUnique) {
	    		   			this.setSchemaDbProperty('unique', true);
	    		   		}


   						if (this._schemaDbProp) {
   							return JSON.stringify(this._schemaDbProp);
   						}
   					},

					function mongooseType() {
						if (this.mongooseRefObject) {
							if (this.isArray) {
								return `{ type: mongoose.ObjectId, ref: '${this.type.metaClass.name}' }`;
							}
							else {
								return `mongoose.ObjectId, ref: '${this.type.metaClass.name}'`;
							}
						}
						else if (this.mongooseSubDoc) {
							return `${this.type.metaClass.name.toLowerCase()}Schema`;
						}
						else {
						   return `'${this.type.mongooseType}'`;
						}
					},

                    function mongooseSubDoc() {
						if (this.isObject) {
							let metaClass = this.type.metaClass;
							if (metaClass.stereotypeName === 'ValueObject' || metaClass.stereotypeName === 'POJO') {
								return true;
							}
						}

						return false;
					},

                    function mongooseRefObject() {
						if (this.isObject) {
							let metaClass = this.type.metaClass;
							return metaClass.isEntity;
						}

						return false;
					},

					function hasIndex() {
						return this.getTagValue('dbIndex');
					},

   					/**
   					* Returns TRUE if this attribute is an object attribute that can and should be 
   					* imported and referenced directly by the schema.
   					*/
   					function importedBySchema() {

						if (this.isObject) {
							if (_.get(this, '_schemaDbProp.persistence') === 'embed' || 
								_.get(this, '_schemaDbProp.foreignKeyField')) {
									return true;
						    }
						}

						return false;
   					}


				]},
			     
			    { func: [
			    	function setSchemaDbProperty(name, value) {
			    		if (!this.hasOwnProperty('_schemaDbProp')) {
			    			this._schemaDbProp = {};
			    		}

			    		this._schemaDbProp[name] = value;
			    	},
			    ]},
			],


			onObjectDatatype: {
				get: [
				    /**
				     * Translates the metamodel's path delimeter into a Javascript appropriate
				     * identifier.
				     */
				    function jsClassNameWithPath() {
	    	   			return TemplateSupport.jsPathToIdentifier(this.classNameWithPath);
				   	}
				],
			},


			onClass: {
				get: [
				    /**
				     * Translates the metamodel's path delimeter into a Javascript appropriate
				     * identifier.
				     */
					function jsClassNameWithPath() {
	    	   			return TemplateSupport.jsPathToIdentifier(this.classNameWithPath);
					},
					

				    /**
				     * Translates the metamodel's package name to a valid Javascript identifier.
				     */
					function jsPackageName() {
	    	   			return TemplateSupport.jsPathToIdentifier(this.packageName);
					},

					function pluralName() {
						return pluralize(this.name);
					},

					function defaultExternalAccess() {
   						// By default, entities's Dao's are internal,
   						// unless there are security roles defined (in which
   						// case they are external but limited to the roles).
   						// All other items are by default, external unless
   						// explicitly turned off.
						if (this.stereotypeName === 'Entity') {
							return this.isRoleRestricted;
						}
						else {
							return true;
						}
					},


   					function allowExternalAccess() {
   						if (!this.hasTag('externalAccess')) {
   							return this.defaultExternalAccess;
   						}
   						else {
							return this.isTaggedAs('externalAccess');
   						}
   					},


					/**
					 * Returns a relative path to prefix import statements that allows
					 * any entry that is using the package path as part of its complete
					 * path to get back up to the parent.  For example, a class with
					 * no package can get to its parent with "..".  A class that is two
					 * levels deep can get to the parent with "../../.."
					 */
                    function relativeParentPrefix() {
						if (this.isRootPackage || this.packageDirName.length == 0) {
							return "..";
						}
						else {
						   const slashCount = (this.packageDirName.match(/\//g) || []).length;
						   return '..' +'/..'.repeat(slashCount+1); // Generate the relative prefix
						}
					},


					/**
					 * A path that includes the package name (if there is one).
					 * The string is formatted so {{packagedirPath}}{{class.name}}.js
					 * will resolve to something correctly without double slashes.
					 */
					function packageDirPath() {
						if (this.inRootPackage) {
							return "";
						}
						else {
							return `${this.packageDirName}/`;
						}
					},


					/**
					* Returns TRUE if there are any dependencies on this class to one or more
					* actors.
					*/
					function isRoleRestricted() {
						return this.roleList.length > 0;
					},


					/**
					 * Returns an array of roles this class is dependent on.  Note
					 * that role dependencies are inherited from parent classes
					 */
					function roleList() {
						if (this.hasOwnProperty('__roleList')) {
							return this.__roleList;
						}

						let roles = [];
						if (this.isSubClass) {
							roles = this.parentClass.roleList;
						}

						this.dependentActors.forEach(function (actor) {
							let roleName = actor.name;
							if (roleName.endsWith('Role')) {
								roleName = _.camelCase(roleName.slice(0, -4));
							}
							roles.push(roleName);
						});

						this.__roleList = roles;

						return roles;
					},


					/**
					* Returns a list of all referenced objects that referenced for
					* direct import by a schema definition.
					*/ 
					function referencedForSchemaImport() {

						let refEmbed = [];

						this.attributes.forEach(function (attribute) {
							if (attribute.importedBySchema) {
								refEmbed.push(attribute.type.metaClass);
							}
						});

						return refEmbed;
					},


					/**
					* Returns a list of all POJO objects that are referenced
					* by this class.
					*/ 
					function embeddedClasses() {

						let embedded = [];

						this.attributes.forEach(function (attribute) {
							if (attribute.mongooseSubDoc) {
								embedded.push(attribute.type.metaClass);
							}
						});

						return embedded;
					},



					/**
					* Returns the stringified version of the roles use.  It will be in the
					* format [ 'role1', 'role2',...]
					*/
					function stringifyRoleList() {
						let strList = JSON.stringify(this.roleList);
						return strList.replace(/"/g, '\'');
					},

					/**
					* Returns the string that should be used to identify this collection.
					*/
					function schemaCollectionName() {
   						return this.getClassNameWithPath('_');
					},

					function autogenPrimaryKey() {
						return this.stereotypeName === 'Entity' && !this.isSubClass;
					},

					function isUserEntity() {
						return this.stereotypeName === 'Entity' && this.name === 'User';
					},

					function isEntity() {
						return this.stereotypeName === 'Entity';
					},

					function isEnumeration() {
						return this.stereotypeName === 'Enumeration' ||
							   this.stereotypeName === 'enumeration';
					}

				],

			},

			onMetaElement: {
				get: [
				    /**
				     * Returns an array of strings representing the comment of the object,
				     * broken down into individual lines that are no longer than (approx) maxCharsPerLine
				     * long.
				     */
	    			function jsCommentsFormatted() {
				    	var maxCharsPerLine = 80;
				    	var lineList = [];
				    	
				    	if (this.hasComment) {
				    		var words = this.comment.split(" ");
				    		var line = "";
				    		var lineLen = 0;
				    		for (var w = 0; w < words.length; w++) {
				    			var nextWord = words[w];
				    			var nextWordLen = nextWord.length;

				    			if (lineLen + nextWordLen > maxCharsPerLine) {
				    				line = line.replace(new RegExp("\\n", "g"), "<p>");
				    				lineList.push(line);
				    				line = "";
				    				lineLen = 0;
				    			}
				    			
				    			if (lineLen > 0) {
				    				line += " ";
				    				lineLen++;
				    			}
				    			
				    			line += nextWord;
				    			lineLen += nextWordLen;
				    		} // for
				    		
				    		if (lineLen > 0) {
			    				line = line.replace(new RegExp("\\n", "g"), "<p>");
				    			lineList.push(line);
				    		}
				    	}
				    	
				    	return lineList;
					},
				],
			},
		}); // end mixin


        // All code from this point on will be executed once just before NodeMDA starts
		// processing classes in the model. This is where we put any special transformations
		// or model additions that are needed for the NodeMDA templates to work.


		// Transform the associations on all of the classes to simple object properties...
		model.classes.forEach(function (metaClass) {
			transformAssocsToAttribs(metaClass);
		});


        // Gather all of the roles defined in the model...
		model.defineEnumerationType('SystemRole', []);
		model.actors.forEach(function (actor) {
			let roleName = actor.name;
			if (roleName.endsWith('Role')) {
				roleName = _.camelCase(roleName.slice(0, -4));
				model.Types.SystemRole.addOption(roleName);				
			}
		});


		// Turn all of the classes marked with the Enumeration stereotype into enumerations...
		model.classes.forEach(function (metaClass) {
			if (metaClass.isEnumeration) {
				model.defineEnumerationType(metaClass.name, []);

				// Now turn each attribute into an option in the enumeration...
				let enumType = model.Types[metaClass.name];
				metaClass.attributes.forEach(function (attrib) {
					enumType.addOption(attrib.name);
				});
			}
		});


		// Finally, find every class that is marked with the "Entity" stereotype and
        // change any attrributes that reference the enumeration class into the
		// enumeration data type.
		model.classes.forEach(function (metaClass) {
			if (metaClass.stereotypeName === 'Entity') {
				metaClass.attributes.forEach(function (attrib) {
					if (attrib.isObject) {
						let attribClass = attrib.type.metaClass;
						if (attribClass && attribClass.isEnumeration) {
							attrib._type = model.Types[attribClass.name];
						}
					}
				});
			}
		});


/*
        // Dump out the entire meta model for plugin development and debugging purposes...
        model.classes.forEach(function (metaClass) {
			if (metaClass.stereotypeName === 'Entity') {
				console.log(`Entity name: ${metaClass.name}`);
				console.log(JSON.stringify(metaClass,null,6));
			}
		});
*/

		// Dump out the classes...
		// Uncomment the code block below to get a dump of the meta model
		/**
		console.log("Class meta model:");
		model.classes.forEach(function (metaClass) {
			console.log(`\nClass: ${metaClass.name} <<${metaClass.stereotypeName}>>`);
			metaClass.attributes.forEach(function (attrib) {
				console.log(`    Attrib: ${JSON.stringify(attrib,null,6)}`);
			});
		});
		*/
	};

	
})();

module.exports = TemplateSupport;
