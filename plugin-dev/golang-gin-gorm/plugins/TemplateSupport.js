"use strict";

const NodeMDA = require("nodemda");
const pluralize = require('pluralize');
const _ = require('lodash');
const OmniSchema = require('omni-schema');
const path = require('path');

/*
 * TemplateSupport.js
 * Contains code that applies to ALL class types generated by this
 * feathers-react plugin.
 */
var TemplateSupport = {};

(function() {


    /**
     * In Go, associations to other objects are handled as
     * nested object properties.  A "many" association is simply an array
     * of those objects. This function transforms any associations on
     * a class object to be "just another attribute" on the class. 
     * The original attribute list and association list are saved in 
     * goOriginalAttributes and goOriginalAssociations in case they 
     * need to be examined.
     */
    function transformAssocsToAttribs(metaClass) {

	    /**
	     * Transforms all of the associations specified in metaClass
	     * into "Attribute" objects, returning them as an array of
	     * NodeMDA.Meta.Attribute objects.
	     */
	    function assocsToArrayAttribs(metaClass) {
	    	let attribs = [];
	    	metaClass.associations.forEach(function(metaAssoc) {
	    	   let myEnd = metaAssoc.myEnd;
	    	   let otherEnd = metaAssoc.otherEnd; 
	    	   if (otherEnd.isNavigable) {
	    		   let attrib = new NodeMDA.Meta.Attribute(otherEnd.name, otherEnd.type);
	    		   attrib._multiplicity = otherEnd._multiplicity;
	    		   attrib._public = otherEnd._public;
	    		   attrib._comment = otherEnd._comment;

	    		   if (otherEnd.type instanceof NodeMDA.Meta.ObjectDatatype) {
	    		   		let otherClass = otherEnd.type.metaClass;
	    		   		if (otherClass.stereotypeName === 'ValueObject' || otherClass.stereotypeName === 'POJO') {
	    		   			attrib.setSchemaDbProperty('persistence', 'embed');
	    		   		}

	    		   		if (otherClass.stereotypeName === 'Entity') {
	    		   			if (myEnd.isNavigable && myEnd.isOne && otherEnd.isMany) {
	    		   				// This is a one to many relationship - configure
	    		   				// as a foreign key...
	    		   				attrib.setSchemaDbProperty('foreignKeyField', myEnd.name);
	    		   			}
	    		   		}
	    		   }

	    		   attribs.push(attrib);
	    	   }	
	    	});
	    	return attribs;
	    };

       let goAttributeList = metaClass.attributes.concat(assocsToArrayAttribs(metaClass));
       metaClass.goOriginalAttributes = metaClass.attributes;
       metaClass.attributes = goAttributeList;
       metaClass.goOriginalAssociations = metaClass.associations;
       metaClass.associations = [];
    };
    
    

	/**
	 * Creates a minimal OmniSchema for the specified class and saves it in the
	 * "schema" property of the meta class object. This schema is used to create
	 * mock records by the unit test generation code.
	 */
	function makeSchema(metaClass) {

		// Build an OmniSchema for this class so we can mock a record...
		let schemaTemplate = {};
		metaClass.allVisibleAttributes.forEach(function(attrib) {
			if (attrib.isObject) {
				schemaTemplate[attrib.name] = { schema: attrib.type.metaClass.schemaCollectionName };
			}
			else {
				schemaTemplate[attrib.name] = { type: attrib.omniSchemaTypeName };
			}
			let omniField = schemaTemplate[attrib.name];
			omniField.validation = {};
			if (attrib.hasMinValue) {
				omniField.validation.min = attrib.minValue;
			}
			if (attrib.hasMaxValue) {
				omniField.validation.max = attrib.maxValue;
			}
		});

		metaClass.schema = OmniSchema.compile(schemaTemplate, metaClass.schemaCollectionName);
	}




    TemplateSupport.goPathToLower = function(packagePath, delim) {

    	if (!delim) {
    		delim = "."
    	}

    	if (typeof packagePath === "string") {
    		return _.toLower(packagePath.replace(new RegExp("\\" + NodeMDA.Options.packageDelimeter, "g"), delim));
    	}
    	else {
    		return "";
    	}
    };

    
    TemplateSupport.goPathWithClass = function(packagePath, className, delim) {

    	if (!delim) {
    		delim = "."
    	}

    	let goPath = TemplateSupport.goPathToLower(packagePath, delim);
    	if (goPath.length > 0) {
    		goPath = goPath + delim;
    	}
    	goPath = goPath + className;

    	return goPath;
    };


    let sourceRoot;
    TemplateSupport.goSourcePath = function() {
    	if (!sourceRoot) {
    		let outputDir = path.resolve(NodeMDA.Options.output);
    		let ndxSrc = outputDir.lastIndexOf('src/');
    		if (ndxSrc === -1) {
    			throw new Error(`Could not locate "src/" in output path ${outputDir}`);
    		}
    		sourceRoot = outputDir.substr(0, ndxSrc+4);
    	}
    	return sourceRoot;
    }


    let projectRoot;
    TemplateSupport.goProjectPath = function() {
    	if (!projectRoot) {
    		let outputDir = path.resolve(NodeMDA.Options.output);
    		let sroot = TemplateSupport.goSourcePath();
    		projectRoot = outputDir.substr(sroot.length+1);
    	}
    	return projectRoot;
    }



	TemplateSupport.initPlatform = function(context) {

		let model = context.model;

		context.goProjectPath = TemplateSupport.goProjectPath();

		model.mixin({

			onAbstractVariable: {
				get: [
					/**
					 * goName is the name to use as the identifier name
					 * for an attribute in a class when generating Go code. 
					 */
					function goName() {
						if (this.isReadOnly || !this.isPublic) {
							// A private variable...
							return _.lowerFirst(this.name);
						}
						else {
							return _.upperFirst(this.name);
						}

   					},


					function goTypeName() {
						if (this.isObject) {
							if (this.isReadOnly || !this.isPublic) {
								// A private variable...
								return _.lowerFirst(this.type.className);
							}
							else {
								return _.upperFirst(this.type.className);
							}
						}
						else {
							return this.type.goTypeName;
						}
			   		},
			

					function omniSchemaTypeName() {
						return this.type.omniSchemaType.name;
			   		},

					function goDefaultValue() {
						if (this.hasDefaultValue) {
							let goValue = this.type.omniSchemaType.fromString(this.defaultValue);
							return JSON.stringify(goValue);
						}
						else if (this.isArray) {
							return "[]";
						}
						else if (this.isObject) {
							return "new " + this.type.goClassNameWithPath() + "()";
						}
						else {
							return this.type.globalDefaultValue;
						}
					},


					function isEntity() {
						if (this.isObject) {
							return this.metaClass.isEntity;
						}
						return false;
					},

				],
			},

			onOperation: {
				get: [
					function goServiceName() {
						return _.lowerFirst(this.name);
					},


					function goReturnType() {
						if (this.hasReturnType) {
							return this._returnType.goTypeName;
						}
						else {
							return "";
						}
					},
				],
			},


			onAttribute: [ 
			   { get: [
   					function schemaDbProperties() {

   						if (this.isObject) {
   							let metaClass = this.type.metaClass;
		    		   		if (metaClass.stereotypeName === 'ValueObject' || metaClass.stereotypeName === 'POJO') {
		    		   			this.setSchemaDbProperty('persistence', 'embed');
		    		   		}
	    		   		}


	    		   		if (this.isUnique) {
	    		   			this.setSchemaDbProperty('unique', true);
	    		   		}


   						if (this._schemaDbProp) {
   							return JSON.stringify(this._schemaDbProp);
   						}
   					},

   					/**
   					* Returns TRUE if this attribute is an object attribute that can and should be 
   					* imported and referenced directly by the schema.
   					*/
   					function importedBySchema() {

						if (this.isObject) {
							if (_.get(this, '_schemaDbProp.persistence') === 'embed' || 
								_.get(this, '_schemaDbProp.foreignKeyField')) {
									return true;
						    }
						}

						return false;
   					},



   					function gormSpec() {

   						let spec = [];

   						if (this.isRequired) {
   							spec.push("not null")
   						}

   						if (this.isUnique) {
   							spec.push("unique_index")
   						}

   						if (_.get(this, '_schemaDbProp.persistence') === 'embed') {
   							spec.push("embedded")
   						}

   						if (spec.length > 0) {
   							sspec = ' gorm:"';
   							for (let i = 0; i < spec.length; i++) {
   								if (i > 0) {
   									sspec += ',';
   								}
   								sspec += spec[i];
   							}
   							sspec += '"';
   							return sspec;
   						}
   						else {
   							return '';
   						}
   					},


				]},
			     
			    { func: [
			    	function setSchemaDbProperty(name, value) {
			    		if (!this.hasOwnProperty('_schemaDbProp')) {
			    			this._schemaDbProp = {};
			    		}

			    		this._schemaDbProp[name] = value;
			    	},
			    ]},
			],


			onObjectDatatype: {
				get: [
				    /**
				     * Translates the metamodel's path delimeter into a Javascript appropriate
				     * identifier.
				     */
				    function goClassNameWithPath() {
	    	   			return TemplateSupport.goPathToIdentifier(this.classNameWithPath);
				   	}
				],
			},


			onClass: {
				get: [

					function isEntity() {
						return this.stereotypeName === 'Entity';
					},


					function goName() {
						if (!this.isPublic) {
							return _.lowerFirst(this.name);
						}
						else {
							return _.upperFirst(this.name);
						}

   					},


					function goPrivateName() {
						return _.lowerFirst(this.name);

   					},

   					function goFileName() {
   						return _.toLower(this.name);
   					},


					function goQualifiedName() {
						return `${this.goPackageName}.${this.goName}`
					},


					function goPackageName() {
						if (this.inRootPackage) {
							return 'root';
						}
						else {
							return _.toLower(this._package.lastPackageName);
						}
					},


					function pluralName() {
						return pluralize(this.name);
					},


					function defaultExternalAccess() {
   						// By default, entities's Dao's are internal,
   						// unless there are security roles defined (in which
   						// case they are external but limited to the roles).
   						// All other items are by default, external unless
   						// explicitly turned off.
						if (this.stereotypeName === 'Entity') {
							return this.isRoleRestricted;
						}
						else {
							return true;
						}
					},


   					function allowExternalAccess() {
   						if (!this.hasTag('externalAccess')) {
   							return this.defaultExternalAccess;
   						}
   						else {
							return this.isTaggedAs('externalAccess');
   						}
   					},


					/**
					 * The name to use for this service in code
					 */
					function serviceVarName() {

						if (this.stereotypeName === 'Entity') {
							return `${this.goName}Dao`;
						}
						else if (this.stereotypeName === 'Service') {
							return `${this.goName}`;
						}
						else {
							throw Error('There is no service path for stereotype ' + this.stereotypeName);
						}

					},


					function ginServicePackagePath() {
						if (this.inRootPackage) {
							return '';
						}
						else {
							return _.toLower(`/${this.packageDirName}`);
						}
					},


					/**
					* Returns the path used to register this service with
					* gin.
					*/
					function ginServicePath() {
						if (this.stereotypeName === 'Entity') {
							return _.toLower(`/${this.ginServicePackagePath}/${this.pluralName}`);
							
						}
						else if (this.stereotypeName === 'Service') {
							return _.toLower(`${this.ginServicePackagePath}/${this.name}`);
						}
						else {
							throw Error('There is no service path for stereotype ' + this.stereotypeName);
						}
					},


					function goPackagePath() {
						return `${TemplateSupport.goSourcePath()}/${this.goImportPath}`;
					},



					/**
					 * The partial path to use to import this service
					 */
					function goImportPath() {

						if (this.inRootPackage) {
							return TemplateSupport.goProjectPath() + '/root';
						}
						else {
							return TemplateSupport.goProjectPath() + '/' + TemplateSupport.goPathToLower(this.packageName, '/');
						}

					},


					function hasImports() {
						return this.referencedForSchemaImport.length > 0;
					},


					/**
					 * Returns a list of paths that should be included in an "import" statement
					 */
					function goImportList() {

						let importSet = new Set(this.referencedForSchemaImport);
						let importList = [];
						importSet.values().forEach(function (metaClass) {
							importList.push(metaClass.goImportPath);
						});

						return importList;
					},


					/**
					* Returns TRUE if there are any dependencies on this class to one or more
					* actors.
					*/
					function isRoleRestricted() {
						return this.roleList.length > 0;
					},


					/**
					 * Returns an array of roles this class is dependent on.  Note
					 * that role dependencies are inherited from parent classes
					 */
					function roleList() {
						if (this.hasOwnProperty('__roleList')) {
							return this.__roleList;
						}

						let roles = [];
						if (this.isSubClass) {
							roles = this.parentClass.roleList;
						}

						this.dependentActors.forEach(function (actor) {
							let roleName = actor.name;
							if (roleName.endsWith('Role')) {
								roleName = _.camelCase(roleName.slice(0, -4));
							}
							roles.push(roleName);
						});

						this.__roleList = roles;

						return roles;
					},


					/**
					* Returns a list of all attributes that are
					* other Entities
					*/ 
					function entityAttributes() {

						if (this.hasOwnProperty('__refEntity')) {
							return this.__refEntity;
						}
						this.__refEntity = [];
						this.attributes.forEach(function (attribute) {
							if (attribute.isEntity) {
								this.__refEntity.push(attribute);
							}
						});
						return this.__refEntity;
					},


					function hasEntityAttributes() {
						return this.entityAttributes.length > 0;
					},


					/**
					* Returns a list of all referenced objects that are referenced for
					* direct import by a schema definition.
					*/ 
					function referencedForSchemaImport() {

						if (this.hasOwnProperty('__refEmbed')) {
							return this.__refEmbed;
						}
						this.__refEmbed = [];
						this.attributes.forEach(function (attribute) {
							if (attribute.importedBySchema) {
								this.__refEmbed.push(attribute.type.metaClass);
							}
						});
						return this.__refEmbed;
					},


					/**
					* Returns the stringified version of the roles use.  It will be in the
					* format [ 'role1', 'role2',...]
					*/
					function stringifyRoleList() {
						let strList = JSON.stringify(this.roleList);
						return strList.replace(/"/g, '\'');
					},

					/**
					* Returns the string that should be used to identify this collection.
					*/
					function schemaCollectionName() {
   						return this.getClassNameWithPath('_');
					},

					function autogenPrimaryKey() {
						return this.stereotypeName === 'Entity' && !this.isSubClass;
					},

				],

			},

			onMetaElement: {
				get: [
				    /**
				     * Returns an array of strings representing the comment of the object,
				     * broken down into individual lines that are no longer than (approx) maxCharsPerLine
				     * long.
				     */
	    			function goCommentsFormatted() {
				    	var maxCharsPerLine = 80;
				    	var lineList = [];
				    	
				    	if (this.hasComment) {
				    		var words = this.comment.split(" ");
				    		var line = "";
				    		var lineLen = 0;
				    		for (var w = 0; w < words.length; w++) {
				    			var nextWord = words[w];
				    			var nextWordLen = nextWord.length;

				    			if (lineLen + nextWordLen > maxCharsPerLine) {
				    				line = line.replace(new RegExp("\\n", "g"), "");
				    				lineList.push(line);
				    				line = "";
				    				lineLen = 0;
				    			}
				    			
				    			if (lineLen > 0) {
				    				line += " ";
				    				lineLen++;
				    			}
				    			
				    			line += nextWord;
				    			lineLen += nextWordLen;
				    		} // for
				    		
				    		if (lineLen > 0) {
			    				line = line.replace(new RegExp("\\n", "g"), "");
				    			lineList.push(line);
				    		}
				    	}
				    	
				    	return lineList;
					},
				],
			},
		}); // end mixin


		// Transform the associations on all of the classes to simple object properties...
		model.classes.forEach(function (metaClass) {
			transformAssocsToAttribs(metaClass);
			let sname = metaClass.stereotypeName;
			if (sname === 'ValueObject' || sname === 'POJO' || sname === 'Entity') {
				makeSchema(metaClass);
			}
		});

	};

	
})();

module.exports = TemplateSupport;
