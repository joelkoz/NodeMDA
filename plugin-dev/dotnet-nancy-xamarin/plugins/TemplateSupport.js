"use strict";

const NodeMDA = require("nodemda");
const pluralize = require('pluralize');
const _ = require('lodash');
const OmniSchema = require('omni-schema');
const Datatypes = require('./Datatypes');

/*
 * TemplateSupport.js
 * Contains code that applies to ALL class types generated by this
 * plugin.
 */
var TemplateSupport = {};

(function() {


    /**
     * In Javascript, associations to other objects are handled as
     * nested object properties.  A "many" association is simply an array
     * of those objects. This function transforms any associations on
     * a class object to be "just another attribute" on the class. 
     * The original attribute list and association list are saved in 
     * jsOriginalAttributes and jsOriginalAssociations in case they 
     * need to be examined.
     */
    function transformAssocsToAttribs(metaClass) {

	    /**
	     * Transforms all of the associations specified in metaClass
	     * into "Attribute" objects, returning them as an array of
	     * NodeMDA.Meta.Attribute objects.
	     */
	    function assocsToArrayAttribs(metaClass) {
	    	let attribs = [];
	    	metaClass.associations.forEach(function(metaAssoc) {
	    	   let myEnd = metaAssoc.myEnd;
	    	   let otherEnd = metaAssoc.otherEnd; 
	    	   if (otherEnd.isNavigable) {
	    		   let attrib = new NodeMDA.Meta.Attribute(otherEnd.name, otherEnd.type);
	    		   attrib._multiplicity = otherEnd._multiplicity;
	    		   attrib._public = otherEnd._public;
	    		   attrib._comment = otherEnd._comment;

	    		   if (otherEnd.type instanceof NodeMDA.Meta.ObjectDatatype) {
	    		   		let otherClass = otherEnd.type.metaClass;
	    		   		if (otherClass.stereotypeName === 'ValueObject' || otherClass.stereotypeName === 'POJO') {
	    		   			attrib.setDbProperty('persistence', 'embed');
	    		   		}

	    		   		if (otherClass.stereotypeName === 'Entity') {
	    		   			attrib.setDbProperty('persistence', 'ref');

	    		   			if (myEnd.isNavigable) {
	    		   				attrib.setDbProperty('foreignPropertyName', myEnd.name);
	    		   				if (myEnd.isOne && otherEnd.isMany) {
			    		   			// This is a one to many relationship - configure
			    		   			// as a foreign key...
			    		   			attrib.setDbProperty('OneToMany', true);
	    			   			}
	    		   			}

	    		   			if (myEnd.type instanceof NodeMDA.Meta.ObjectDatatype) {
	    		   				let myClass = myEnd.type.metaClass;
	    		   				if (myClass.stereotypeName === 'Entity') {
	    		   					if (otherEnd.isNavigable) {
	    		   						attrib.setDbProperty('circularDbReference', true);
	    		   						if (myEnd.isMany && otherEnd.isOne) {
	    		   							attrib.setDbProperty('ManyToOne', true);
	    		   						}
	    		   					}
	    		   				}
	    		   			}

	    		   		}
	    		   }

	    		   attribs.push(attrib);
	    	   }	
	    	});
	    	return attribs;
	    };

       let jsAttributeList = metaClass.attributes.concat(assocsToArrayAttribs(metaClass));
       metaClass.jsOriginalAttributes = metaClass.attributes;
       metaClass.attributes = jsAttributeList;
       metaClass.jsOriginalAssociations = metaClass.associations;
       metaClass.associations = [];
    };
    
    

	/**
	 * Creates a minimal OmniSchema for the specified class and saves it in the
	 * "schema" property of the meta class object. This schema is used to create
	 * mock records by the unit test generation code.
	 */
	function makeSchema(metaClass) {

		// Build an OmniSchema for this class so we can mock a record...
		let schemaTemplate = {};
		metaClass.allVisibleAttributes.forEach(function(attrib) {
			if (attrib.isObject) {
				schemaTemplate[attrib.name] = { schema: attrib.type.metaClass.schemaCollectionName };
			}
			else {
				schemaTemplate[attrib.name] = { type: attrib.omniSchemaTypeName };
			}
			let omniField = schemaTemplate[attrib.name];
			omniField.validation = {};
			if (attrib.hasMinValue) {
				omniField.validation.min = attrib.minValue;
			}
			if (attrib.hasMaxValue) {
				omniField.validation.max = attrib.maxValue;
			}
		});

		metaClass.schema = OmniSchema.compile(schemaTemplate, metaClass.schemaCollectionName);
	}




    /**
     * Takes a string and translates it into a valid Javascript identifier.
     */
    TemplateSupport.jsPathToIdentifier = function(packagePath) {
    	if (typeof packagePath === "string") {
    		return packagePath.replace(new RegExp("\\" + NodeMDA.Options.packageDelimeter, "g"), ".");
    	}
    	else {
    		return "";
    	}
    };
    

    /**
     * Takes a string and translates it into a valid Javascript identifier.
     */
    TemplateSupport.jsPathToDirectory = function(packagePath) {
    	if (typeof packagePath === "string") {
    		return packagePath.replace(new RegExp("\\.", "g"), "/");
    	}
    	else {
    		return "";
    	}
    };
    


    TemplateSupport.generateGUID = function() {

	    var d = new Date().getTime();
	    if(Date.now){
	        d = Date.now(); //high-precision timer
	    }
	    var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
	        var r = (d + Math.random()*16)%16 | 0;
	        d = Math.floor(d/16);
	        return (c=='x' ? r : (r&0x3|0x8)).toString(16);
	    });
	    return uuid;
    }


    Array.prototype.addToSet = function(entry) {
    	// Check to see if it already exists.
    	for (let i = 0; i < this.length; i++) {
    		if (this[i] == entry) {
    			return false;
    		}
    	}

    	this.push(entry);
    	return true;
    }


	TemplateSupport.initPlatform = function(context) {

		let model = context.model;

		model.mixin({

			onAttribute: [ 
			   { get: [
					/**
					 * jsIdentifierName is the name to use as the identifier name
					 * for an attribute in a class when generating Javascript code. 
					 * The convention used is that read only and private variables are prefixed
					 * with the "_" character.
					 */
					function jsIdentifierName() {
						if (this.isReadOnly || !this.isPublic) {
							// A private variable...
							return "_" + this.name;
						}
						else {
							return this.name;
						}

   					},

   					function firstUpperName() {
   						return _.upperFirst(this.name);
   					},

   					function dbProperties() {

   						if (this.isObject) {
   							let metaClass = this.type.metaClass;
		    		   		if (metaClass.stereotypeName === 'ValueObject' || metaClass.stereotypeName === 'POJO') {
		    		   			this.setDbProperty('persistence', 'embed');
		    		   		}
	    		   		}


	    		   		if (this.isUnique) {
	    		   			this.setDbProperty('unique', true);
	    		   		}


   						return this._dbProps;

   					},


   					function isEntity() {
   						return this.isObject && this.type.metaClass.isEntity;
   					},


   					function isEntityArray() {
   						return this.isEntity && this.isArray;
   					},


   					function saveAsForeignKey() {
   						if (this.isEntity) {
   							return Boolean(this._dbProps.foreignPropertyName);
   						}
   						else {
   							return false;
   						}
   					},


   					function bsonIgnore() {

   						if (this.isTaggedAs('dbIgnore')) {
   							return true;
   						}
	    				else if (this.hasOwnProperty('_dbProps')) {
	    					let db = this._dbProps;
	    					return db.circularDbReference && db.OneToMany;
	    				}

   						return false;
   					},


   					function bsonRef() {

	    				if (this.hasOwnProperty('_dbProps')) {
	    					let db = this._dbProps;
	    					return !db.circularDbReference || db.ManyToOne;
	    				}

   						return false;
   					},


				]},
			     
			    { func: [
			    	function setDbProperty(name, value) {
			    		if (!this.hasOwnProperty('_dbProps')) {
			    			this._dbProps = {};
			    		}

			    		this._dbProps[name] = value;
			    	},
			    ]},
			],

			onOperation: [
				{ get: [
					 function csReturnType() {
						if (this.hasReturnType) {
							return this.type.csTypeName;
						}
						else {
							return "void";
						}
					 },
				  ],
				}
			],

			onObjectDatatype: {
				get: [
				    /**
				     * Translates the metamodel's path delimeter into a Javascript appropriate
				     * identifier.
				     */
				    function jsClassNameWithPath() {
	    	   			return TemplateSupport.jsPathToIdentifier(this.classNameWithPath);
				   	}
				],
			},

			onDatatype: {
				get: [
					function csTypeName() {
						if (this._csTypeName) {
							return this._csTypeName;
						}
						else if (this.isObject) {
							return this.className;
						}
						else {
							console.log('Could not determine CS type name for datatype ' + this.name); 
						}
					}
				],		
			},

			onClass: {
				get: [
				    /**
				     * Translates the metamodel's path delimeter into a Javascript appropriate
				     * identifier.
				     */
					function jsClassNameWithPath() {
	    	   			return TemplateSupport.jsPathToIdentifier(this.classNameWithPath);
					},
					

				    /**
				     * Translates the metamodel's package name to a valid Javascript identifier.
				     */
					function jsPackageName() {
	    	   			return TemplateSupport.jsPathToIdentifier(this.packageName);
					},

					function pluralName() {
						return pluralize(this.name);
					},


					function defaultExternalAccess() {
   						// By default, entities's Dao's are internal,
   						// unless there are security roles defined (in which
   						// case they are external but limited to the roles).
   						// All other items are by default, external unless
   						// explicitly turned off.
						if (this.stereotypeName === 'Entity') {
							return this.isRoleRestricted;
						}
						else {
							return true;
						}
					},


   					function allowExternalAccess() {
   						if (!this.hasTag('externalAccess')) {
   							return this.defaultExternalAccess;
   						}
   						else {
							return this.isTaggedAs('externalAccess');
   						}
   					},



					/**
					* Returns TRUE if there are any dependencies on this class to one or more
					* actors.
					*/
					function isRoleRestricted() {
						return this.roleList.length > 0;
					},


					/**
					 * Returns an array of roles this class is dependent on.  Note
					 * that role dependencies are inherited from parent classes
					 */
					function roleList() {
						if (this.hasOwnProperty('__roleList')) {
							return this.__roleList;
						}

						let roles = [];
						if (this.isSubClass) {
							roles = this.parentClass.roleList;
						}

						this.dependentActors.forEach(function (actor) {
							let roleName = actor.name;
							if (roleName.endsWith('Role')) {
								roleName = _.camelCase(roleName.slice(0, -4));
							}
							roles.push(roleName);
						});

						this.__roleList = roles;

						return roles;
					},



					/**
					* Returns the stringified version of the roles use.  It will be in the
					* format [ 'role1', 'role2',...]
					*/
					function stringifyRoleList() {
						let strList = JSON.stringify(this.roleList);
						return strList.replace(/"/g, '\'');
					},

					/**
					* Returns the string that should be used to identify this collection.
					*/
					function schemaCollectionName() {
   						return this.getClassNameWithPath('_');
					},

					function autogenPrimaryKey() {
						return this.stereotypeName === 'Entity' && !this.isSubClass;
					},


					/**
					* Returns TRUE if any of the attributes of this class is an array.
					*/
					function hasArrayAttribs() {

						let multiples = false;
						this.attributes.forEach(function (attribute) {
							if (attribute.isArray) {
								multiples = true;
							}
						});
						return multiples;
					},


					function isEntity() {
						return this.stereotypeName === 'Entity';
					},

					function hasEntityMembers() {

						let entityRefs = false;
						this.attributes.forEach(function (attribute) {
							if (attribute.isEntity) {
								entityRefs = true;
							}
						});

						return entityRefs;
					},


					function hasEntityArrayMembers() {

						let entityRefs = false;
						this.attributes.forEach(function (attribute) {
							if (attribute.isEntityArray) {
								entityRefs = true;
							}
						});

						return entityRefs;
					},


   					function Namespace() {
   						return context.libraryNamespace + (!this.inRootPackage ? "." + this.jsPackageName : "");
   					},


   					function NamespaceSourceDir() {
   						return context.output + "/" + TemplateSupport.jsPathToDirectory(this.Namespace);
   					},

   					function ServerNamespace() {
   						return context.libraryNamespace + ".Server" + (!this.inRootPackage ? "." + this.jsPackageName : "");
   					},

   					function ServerNamespaceSourceDir() {
   						return context.output + "/" + TemplateSupport.jsPathToDirectory(this.ServerNamespace);
   					},

   					function ClientNamespace() {
   						return context.libraryNamespace + ".Client" + (!this.inRootPackage ? "." + this.jsPackageName : "");
   					},

   					function ClientNamespaceSourceDir() {
   						return context.output + "/" + TemplateSupport.jsPathToDirectory(this.ClientNamespace);
   					},


					function foreignNamespaces() {
						let nspaces = [];
						let clazz = this;

						if (clazz.isSubClass && clazz.parentClass.Namespace != clazz.Namespace) {
							nspaces.addToSet(clazz.parentClass.Namespace);
						};

						clazz.attributes.forEach(function (attribute) {
							if (attribute.isEntity && attribute.type.metaClass.Namespace != clazz.Namespace) {
								nspaces.addToSet(attribute.type.metaClass.Namespace);
							}

							if (attribute.type.csRequiredImport) {
								nspaces.addToSet(attribute.type.csRequiredImport);
							}
						});
						return nspaces;
					},


					function foreignServerNamespaces() {
						let nspaces = [];
						let clazz = this;
						clazz.attributes.forEach(function (attribute) {
							if (attribute.isEntity && attribute.type.metaClass.ServerNamespace != clazz.ServerNamespace) {
								nspaces.addToSet(attribute.type.metaClass.ServerNamespace);
							}

							if (attribute.isEntity && attribute.type.metaClass.Namespace != clazz.Namespace) {
								nspaces.addToSet(attribute.type.metaClass.Namespace);
							}

							if (attribute.type.csRequiredImport) {
								nspaces.addToSet(attribute.type.csRequiredImport);
							}
						});
						return nspaces;
					}

				],

			},

			onMetaElement: {
				get: [
				    /**
				     * Returns an array of strings representing the comment of the object,
				     * broken down into individual lines that are no longer than (approx) maxCharsPerLine
				     * long.
				     */
	    			function jsCommentsFormatted() {
				    	var maxCharsPerLine = 80;
				    	var lineList = [];
				    	
				    	if (this.hasComment) {
				    		var words = this.comment.split(" ");
				    		var line = "";
				    		var lineLen = 0;
				    		for (var w = 0; w < words.length; w++) {
				    			var nextWord = words[w];
				    			var nextWordLen = nextWord.length;

				    			if (lineLen + nextWordLen > maxCharsPerLine) {
				    				line = line.replace(new RegExp("\\n", "g"), "<p>");
				    				lineList.push(line);
				    				line = "";
				    				lineLen = 0;
				    			}
				    			
				    			if (lineLen > 0) {
				    				line += " ";
				    				lineLen++;
				    			}
				    			
				    			line += nextWord;
				    			lineLen += nextWordLen;
				    		} // for
				    		
				    		if (lineLen > 0) {
			    				line = line.replace(new RegExp("\\n", "g"), "<p>");
				    			lineList.push(line);
				    		}
				    	}
				    	
				    	return lineList;
					},
				],
			},
		}); // end mixin


		// Transform the associations on all of the classes to simple object properties...
		model.classes.forEach(function (metaClass) {
			transformAssocsToAttribs(metaClass);
			let sname = metaClass.stereotypeName;
			if (sname === 'ValueObject' || sname === 'POJO' || sname === 'Entity') {
				makeSchema(metaClass);
			}
		});

		// Generate some guids used by the Visual Stuio solution file.
		context.guids = {};
		context.guids.solution = "{" + TemplateSupport.generateGUID() + "}";
		context.guids.library = "{" + TemplateSupport.generateGUID() + "}";
		context.guids.server = "{" + TemplateSupport.generateGUID() + "}";

		Object.defineProperty(context, "libraryName", { get: function() { return this.model.name + "Services"; }});

		Object.defineProperty(context, "libraryNamespace", { get: function() { return this.libraryName; }});

		Object.defineProperty(context, "rootServiceUri", { get: function() { return this.libraryName; }});

		Object.defineProperty(context, "serverProjectName", { get: function() { return this.libraryName + "StandaloneServer"; }});

		Object.defineProperty(context, "serverProjectNamespace", { get: function() { return this.serverProjectName; }});

		context.eq = function(param1, param2) {
			return param1 === param2;
		}

		context.notEq = function(param1, param2) {
			return param1 !== param2;
		}


	};

	
})();

module.exports = TemplateSupport;
